<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js WebXR AR Cube Placement</title>
    <!-- Load Tailwind CSS for simple styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1f2937; }
        /* Style for the AR Button, ensuring it sits nicely on the screen */
        #ARButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            font-size: 1.2rem;
            color: white;
            background-color: #10b981; /* Green for AR */
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s;
        }
        #ARButton:hover {
            background-color: #059669;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script type="module">
        // Using three.js r137 for better WebXR support
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.137.0/build/three.module.js';
        
        // Import the ARButton helper instead of VRButton
        import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.137.0/examples/jsm/webxr/ARButton.js';

        // --- Core Scene Setup Variables ---
        let scene, camera, renderer;
        let cubeTemplate; // The cube to be placed
        
        // --- AR Specific Variables ---
        let controller;
        let reticle; // The marker to show where the object will be placed
        let hitTestSource = null;
        let referenceSpace = null; // Stored reference space for hit-testing
        let hitTestSourceRequested = false;

        function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            
            // 2. Camera Setup (The camera position will be managed by the AR headset/phone)
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            // 3. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Alpha is true for AR transparency
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = '0';
            document.body.appendChild(renderer.domElement);
            
            // Enable XR for the renderer
            renderer.xr.enabled = true;
            
            // Set output encoding for better colors (optional but good practice)
            renderer.outputEncoding = THREE.sRGBEncoding;

            // 4. Add the WebXR AR Button 
            // We use ARButton.createButton which handles session requests and error logging for us.
            // The catch block logs session failure reasons for better debugging.
            try {
                const button = ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] });
                document.body.appendChild(button);
            } catch (e) {
                console.error("AR Button setup failed:", e);
                const errorDiv = document.createElement('div');
                errorDiv.innerText = "Error setting up AR. Ensure your device/browser supports WebXR.";
                errorDiv.style.color = 'red';
                document.body.appendChild(errorDiv);
            }
            

            // 5. Lighting
            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);

            // 6. Cube Template (The object we will clone and place)
            const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const material = new THREE.MeshPhongMaterial({ color: 0xffa500 });
            cubeTemplate = new THREE.Mesh(geometry, material);
            // Don't add it to the scene yet, it's just a template.

            // 7. Reticle (The visual marker for placement)
            // It uses a simple double-ring pattern to indicate position
            const reticleGeometry = new THREE.RingGeometry(0.08, 0.1, 32).rotateX(-Math.PI / 2);
            const reticleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
            reticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
            reticle.matrixAutoUpdate = false; 
            reticle.visible = false;
            scene.add(reticle);

            // 8. Controller and Event Listeners
            controller = renderer.xr.getController(0);
            controller.addEventListener('select', onSelect); 
            scene.add(controller);
            
            // Setup session listeners
            renderer.xr.addEventListener('sessionstart', setupSession);
            renderer.xr.addEventListener('sessionend', () => {
                hitTestSourceRequested = false;
                hitTestSource = null;
                referenceSpace = null;
                reticle.visible = false;
            });


            // 9. Handle window resizing
            window.addEventListener('resize', onWindowResize, false);

            // Start the animation loop
            renderer.setAnimationLoop(animate);
        }
        
        // Function to handle the 'select' event (user tap)
        function onSelect() {
            if (reticle.visible) {
                // Clone the template cube and place it at the reticle's position
                const newCube = cubeTemplate.clone();
                
                // Use reticle's matrix to set the cube's position/orientation
                reticle.matrix.decompose(newCube.position, newCube.quaternion, newCube.scale);
                scene.add(newCube);
                
                // Add a little spin animation on placement
                newCube.rotation.x = Math.random() * Math.PI * 2;
                newCube.rotation.y = Math.random() * Math.PI * 2;
                
                // Log placement for debugging
                console.log('Cube placed at:', newCube.position);
            }
        }
        
        // Function to set up AR session specific resources
        function setupSession() {
            const session = renderer.xr.getSession();

            if (session) {
                // FIX 1: Request the 'local' reference space. This provides a stable origin point
                // which often works better than 'viewer' for initial surface finding.
                session.requestReferenceSpace('local').then(space => {
                    referenceSpace = space;
                    
                    // Request a hit test source starting from the 'viewer' space
                    session.requestHitTestSource({ space: session.requestReferenceSpace('viewer') }).then(source => {
                        hitTestSource = source;
                        hitTestSourceRequested = true;
                        reticle.visible = true;
                        console.log('AR Session Started. Hit testing active. Reference space: local');
                    }).catch(e => {
                        console.error("Failed to request hit test source. Hit-testing will not work:", e);
                    });

                }).catch(e => {
                    console.error("Failed to request local reference space:", e);
                });
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate(timestamp, frame) {
            // Check if we are inside a frame with valid data AND we have reference space
            if (frame && referenceSpace) {
                
                // Check if hit testing is set up and requested
                if (hitTestSourceRequested === true && hitTestSource !== null) {
                    
                    try {
                        // CRITICAL: Use the referenceSpace saved in the setupSession function
                        const hitTestResults = frame.getHitTestResults(hitTestSource);

                        if (hitTestResults.length > 0) {
                            // Hit test success
                            const hit = hitTestResults[0];

                            // Get the transformation matrix from the hit result based on our established reference space
                            const matrix = hit.getPose(referenceSpace).transform.matrix;
                            
                            // Position the reticle
                            reticle.matrix.copy(matrix);
                            reticle.visible = true;

                        } else {
                            // No surface found
                            reticle.visible = false;
                        }
                    } catch (e) {
                        // Catching errors during hit-test processing, which can stop the animation loop
                        console.error("Error during hit-test processing (potential cause of freezing):", e);
                        reticle.visible = false;
                    }
                }
            } else {
                // If frame is null or referenceSpace is null, the app should fall back to standard desktop mode,
                // but since we are in setAnimationLoop, this is the XR system's job.
                // We keep rendering outside the frame block to allow desktop mode if session ends.
            }
            
            // Render the scene
            renderer.render(scene, camera);
        }

        // Initialize the app when the window loads
        window.onload = init;

    </script>
</body>
</html>
